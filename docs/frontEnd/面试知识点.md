# 前端重要技术点详细讲解

### 字节跳动（20190202）
- 一面
1. 基础知识
- axios或fetch的用法：
```javascript
function getData(url, data){
    // axios
    axios(url, data).then((res) => {
        console.log(res.data)
    }).catch((error) => {
        console.log(error)
    })
     // axios
    axios(
        {
            method: url, 
            params: data
        }
    )
    .then((res) => {
        console.log(res.data)
    })
    .catch((error) => {
        console.log(error)
    })
    // fetch
    fetch(url, data).then((res) => {
        res.json()
    }).catch((error) => {
        console.log(error)
    })
    // fetch
    fetch(url,
    {
        method: 'POST',
        body: data,
        headers: new Headers({'Content-Type': 'application/json'})
    }).then((res) => {
        res.json()
    }).catch((error) => {
        console.log(error)
    })
}   
```
2. promise实现delay(ms)延时函数
```javascript
    function delay(ms){
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve()
            }, ms)
        })
    }
```
3. react hook使用过吗
    使用过。react hook为react提供了提供了生命周期的功能，实现了监听状态变化和页面更新的功能。常用的hooks有useState、useEffect、useMemo、useCallback、useRef、useContext、useReducer等.其中useState是定义状态变量。useEffect对应了生命周期componentDidMount，但是监听的对象对象需要在通过给useEffect传参的形式实现。

4. 实现数组转链表
```javascript
    function arr2list(arr){
        class node{
            constructor(value, nextNode){
                this.value = value
                this.nextNode = nextNode
            }
        }
        const next = null
        for(let i = arr.length - 1; i >= 0; i--){
            arr[i] = new Node(arr[i], next)
            next = arr[i]
        }
        return next
    }
    function printList(list){
        let pointer = list
        whlie(pointer){
            console.log(pointer.value)
            pointer = pointer.nextNode
        }
    }
```
5. react中的函数组件和类组件有什么区别，实现一个函数来区分函数组建和类组件
    函数组件是函数形式的组件，在内部使用hooks监听状态和实现组件更新。函数组件通过props传参的形式实现父子组件间的信息传递，返回react的节点元素
    类组件是是使用类语法定义的组件，在内部使用react生命周期函数。通过constructor内部定义状态变量state，并定义内部的render函数返回react节点。
    如何实现一个函数来区分函数组件和类组件，我想可以使用以下方法：
    通过new一个对象判断该对象是否有rendor函数来实现。
6. html生成的DoM树是怎么样的。请用代码实现以下Dom结构
    Dom树的结构根节点为document，后面是html节点，再下面是元素head和元素body，head元素后是title，title后是文本节点。body下面可以是各种元素组合成的树形结构，比如a标签、h1标签等等，a标签又包含了href属性标签节点。可以绘制一个属性结构进行描述
    example：
    ```javascript
        1. const a = <div a={1}>click</div>
        2. const b = <Button disabled>click</Button>
    ```
    代码实现DOM结构，首先要清楚node节点的表示方法：
    ```javascript
    class Node{
        contructor(
            nodeName,
            nodevalue,
            nodeType, // 1: 元素，2: 属性，3: 文本，8: 注释，9: 文档
            parentNode,
            childNodes, 
            firstChild, 
            lastChild,
            attributes,
            previousSibling,
            nextSibling,
            innerHTML
        ){
            this.nodeName =nodeName
            ....
        }
    }
```javascript
// a的dom结构
const node2 = new Node('a', {1}, 2, null, null, null, null, null, null, null, null)
const node3 = new Node('#text', 'click', 3, null, null, null, null, null, null, null, null)
const node1 = new Node('div', null, 1, null, [node3], node3, node3, node2, null, null, 'click')
```
7. 了解虚拟Dom吗，用代码判断两个element是否全等。
    虚拟Dom的结构如下：
```javascript
class VNode{
    constructor(
        tag, // 标签类型：DIV、SPAN、#text
        el, // 对应的真实节点 Node类型
        children, // 当下节点下的子节点
        text, // 当前虚拟节点的文本
        data, // VNodeData(??)
        parent, // 父级节点 
        nodeType //  节点类型
    ){
        this.tag = tag
        ......
    }
}
    参考SnabbDOM：
    export interface VNodeData {
        props?: Props;
        attrs?: Attrs;
        class?: Classes;
        style?: VNodeStyle;
        dataset?: Dataset;
        on?: On;
        hero?: Hero;
        attachData?: AttachData;
        hook?: Hooks;
        key?: Key;
        ns?: string; // for SVGs
        fn?: () => VNode; // for thunks
        args?: Array<any>; // for thunks
        [key: string]: any; // for any other 3rd party module
    }
```
    如何判断是否全等？(全等的概念是什么意思？)
    1、对引用类型而言，全等的意思就是要求引用地址相同
    2、全等不要求引入地址相同，只需要内容一致，通过深度遍历对象实现
#### 二面
1. display有哪些属性
    display： none unset initial inherit contents inline inline-block block flex grid table
2. flex能否实现元素竖排
    可以。主轴和交叉轴互换位置
3. css行内元素和块级元素的区别
    - 开启新行
    - 高度是否可以设定
    - 宽度是否可以设定
    - 内联元素只能容纳文本或者其他内联元素
4. 有哪些提升浏览器性能的方式
    - 资源分包
    - 懒加载
    - 减少请求次数
    - 静态资源CDN
    - 静态资源缓存
    - 资源文件压缩
    - 代码结构优化：减少循环、变量缓存、垃圾回收、减少dom结构的层级、节点缓存
    - 减少页面重绘和重排： 1、减少DOM节点的修改。 2、不要循环修改DOM的样式，最好使用改变className的方式实现样式的修改。3、定位为absolute和fixed的元素，修改它们的样式不会发生重排的
5. 从url输入到页面渲染完毕都经历了什么（包括通信部分和页面渲染）
    - url输入
    - DNS域名解析
    - 开始TCP三次握手
    - http内容传输
    - 客户端获得页面开始渲染解析，生成dom树，然后生成renderDom树，最后将页面进行绘制
6. 重绘和重排怎么理解？如何减少？
    当页面元素节点发生变化的时候，页面需要进行重新渲染，这个时候会发生重绘和重排
    - 重排一定会发生重绘，重绘不一定发生重排
    - 重排列的条件：
     - 页面渲染初始化
     - 添加、删除dom元素
     - 元素的位置改变
     - dom元素的尺寸改变
     - 浏览器窗口的尺寸改变
7. http有哪些请求方式？有什么区别？
    post get head options put delete connect trace 
    post：包含了请求头和请求主体 
    get：请求页面，没有请求body
    options：预检请求，可用于检测服务器的链接状态
    put: 从客户端向服务器传送的数据取代指定的内容
    head：跟get请求类似，响应只包含了报文头
    delete: 请求服务器删除指定的页面
    connect：将链接 改为 管道方式的代理服务器，用于传输http报文
    trace：回显服务器的请求，主要用于诊断和测试

8. http请求和收到的字段有哪些？有什么作用？
    请求字段
    通用头部：cache-control、Date、Pragma、connection、trailer、transfer-encoding、upgrade、via、warning
    请求头部：
    Host
    User-Agent
    Accept
    Accept-Language
    Accept-Encoding: zip
    Accept-Charset: UTF-8
    Cookie
    Referer
    User-Agent
    Connection
    Cache-Control
    Range

    接受头部：
    - Cache-Control
    - Content-Type: application/json multipart/form-data application/x-www-form-urlencoded text/xml 
    - Content-Encoding: zip
    - Date
    - Server
    - Transfer-Encoding: chuncked
    - Expires
    - Last-Modifyied
    - Connection
    - ETag
    - Refresh
    - Access-Control-Allow-Origin
    - Access-Control-Allow-Methods
    - Access-Control-Allow-Credencials
    - Content-Range
    - Location  // 重定向的位置
    - Set-Cookie

    origin和referer的区别：origin不携带路径，包含协议和host地址，只存在于post页面。可以用referrer-policy来监管哪些访问源信息会在referrer中送
9. 算法：财务室需要进行数字的处理，将1234567.90转化为1,234,567.90(适用于所有数字，要考虑特殊情况)
```javascript
    // 判断有没有小数点位置
    function toAcounting(num){
        let str = String(num)
        const index = str.indexOf('.')
        let start = 0
        let end = str.length
        if(index > -1){
             start = 0
             end = index
        }
        let loop = end
        while(loop > 3){
            str = str.slice(0, loop - 4)  + ',' + str.slice(loop-4, str.length)
            loop = loop - 4
        }
        return str
    }
```

- 三面
1. 讲一下你做过的项目，在项目中负责什么。

2. 在项目中遇到那些困难，是怎么解决的。
3. 不同页面间通信的方法，写代码。
 - js中可以使用storage来在同源页面进行通信
```javascript
    window.localStorage.setItem('a', 123)
    window.addEventListner('storage', (e) => {
        console.log(e.key, e.value)
    })
```
 - 非同源页面可以使用postMessage的方式来进行页面之间的通信
```javascript
    window.postMessage('12345', 'www.baidu.com')
    window.onmessage = (e) => {
        console.log(e.data, e.origin)
    }
```

4. 在构造函数中用bind绑定函数，前后是不是同一个（this指向考察）。
    - bind之后的函数和原函数不是同一个，地址不同
5. 如何收集产品发布后，实用阶段的问题。
    - 从问题维度：1、可能是生产bug，生产bug是需要及时响应和解决的问题，通常版本发布之后，测试同事会直接在线上验证，出现问题通知开发进行修复，并进行线上缺陷记录开启bug生命周期；2、可能是用户体验问题，这个可以由专门的产品体验官提供体验报告。可以从线上访问数据，如埋点的手段获得访问数据并进行分析，从而知道哪些功能更用户青睐，哪些功能有待改进。可以通过产品优化的方式，如通过app手机用户意见、反馈和投诉的方式实现实用阶段的问题；
    - 从收集渠道角度考虑： 1、测试出的生产bug。2、埋点收集待优化的功能。3、产品体验官的体验报告。4、产品的用户意见、反馈和投诉相关功能。5、线下用户回访。6、ABTest手段。6、灰度测试手段。其中一些寻找实用阶段问题的手段是需要其他工作人员配合完成的

### 微众银行（20210914）
1. （项目导向）如何实现请求资源缓存的更新、如何保证请求的安全（预防中间者攻击）
- 1、缓存更新与expires、Etag、cache-control头部有关。可以通过协商缓存来实现缓存的更新。2、或者及时清理客户端缓存，可以实现。
- 使用https加密
2. （项目导向）怎么实现nodejs应用服务的高可用，多实例如何分配资源，单实例重启时如何做到分配其他实例进行处理。继续向上拓展，如何做到处理负载均衡的代理重启时的资源分配
- 使用pm2启用多个node程序同时提供服务。
- 通过ng配置或者pm2配置实现
3. （项目导向）为什么项目里面又有gulp、又有webpack，谈下你对这两个区别的理解
- gulp是工作流形式的打包。每个步骤实现一种功能。webpack的对象是模块，打包的时候，从入口文件开始，遇到新的模块，使用相应的规则对其进行打包。
4. （项目导向）谈下你对HTTPS的理解，和HTTP有啥区别，这里面的连接过程是怎样的，为什么同时有对称加密和非对称加密。拓展：Android签名是怎样的（我做过Android开发）
- https是网络传输应用层协议。它在http的基础上实现了加密、身份认证、数据完整性校验的功能。HTTP是基于TCP协议，所以先进行TCP3次握手建立连接。非对称加密加密对称加密的密钥。非对称加密主要用在2个地方：1、加密数字证书、加密会话密钥
5. HTTP状态码
2** 表示连接正常 204:服务器成功处理了请求，但没返回任何内容。
3** 重定向
4** 找不到服务
5** 服务器报错。根据具体情况进行排查，也可能是代理、网关问题。

6. 简述你用过ES6哪些特性
- let、const变量。块级作用域
- 箭头函数
- promise异步函数和一步编程
- 字面量
- symbol
- Set Map
- 迭代器和生成器
- 类
- proxy代理和reflection反射
- 模块封装

7. ES6里面的Generator底层是怎么实现的
generate被称为惰性函数。通过使用next方法触发函数的执行。可以实现执行和暂停操作。底层原理是依赖闭包的实现。在babel转换中，会将其实现为一个switch函数，并用一个状态变量记录当前执行的状态。

8. 如果给一个数组，要求往里面不断加入方法，要求方法不重复，怎么实现。（1、要求加入的只能是方法，2、方法不能重复（方法实例不能重复，不是运行结果不能重复））
- 不能重复是什么意思？实例不能重复的意思是地址不能重复？

9. 你用闭包做过什么
- 监听函数引入外部变量形成闭包
- 循环中的函数引入变量，使用let + 闭包

10. （项目导向）谈下对Hybrid开发的理解
- 混合开发是继原生开发之后，出现的一种APP开发模式。这种模式使APP开发摆脱了传统原生开发的复杂和难度。web开发人员可以快速上手，开发效率大大提高。一套代码通过编译实现多端使用，ios和android都可以，大大降低维护成本。同时随着Hybrid的发展，api增强，它调用原生功能的能力也在加强。
- Hybrid开发框架包括web app、React Native、flutter、weex、pwa、hybrid app、微信小程序

11. 讲下你用过什么排序，实现原理是什么
- 冒泡排序，选择排序、sort排序

1. 为什么选择vue
2. vue 双向绑定
3. vue nextTick实现
- 首先nextTick实现功能是在数据状态更新之后，使用js立刻执行一段代码，操作新视图的时候用到。
4. event loop事件轮询的执行顺序
- 首先是顺序执行代码，当遇到异步代码先存入异步队列，异步队列分为微队列和宏队列，当顺序执行代码完成以后，取出微队列的异步代码执行，直到清空异步队列，然后是执行宏队列的代码。
5. es5 的promise 实现
- 闭包实现
```javascript
    const Promise = function(fn){
        if(typeof this !== 'object'){
            throw new TypeError('error')
        }
        if(typeof fn !== 'function'){
            throw new TypeError('error')
        }
        this. state = 'pendding'
        this.msg = ''
        const that = this
        fn1 = fn
        const resolve1 = function(){
            that.state = 'resolve'
            that.msg = arguments[0]
        }
        const reject1 = function(){
            that.state = 'reject'
            that.msg = arguments[0]
        }
        fn1(resolve1, reject1)
        return this
    }
    Promise.protoType.then = () => {
        if(this.state === 'resolve'){
            arguments[0](this.msg)
        }
        if(this.state === 'reject' && arguments[1]){
            arguments[1](this.msg)
        }

        const res = new this.constructor(function(resolve, reject){rconsole.log('test2')})
        return res

    }
```
6. 每个图片格式的作用
- 图片格式包括：png、svg、jpeg、gif、webp等
- 图片类型： 常规图片、雪碧、字体图片、canvas转换图片
7. 如果服务端不支持判断webp，怎么做
- 客户端将图片进行判断，并进行转换成服务端支持的格式
8. 项目的性能优化，怎么做
- 静态资源优化：图片资源压缩、打包压缩、cdn代理、负载均衡
- 资源预请求
- 资源懒加载、图片懒加载
- 减少页面的重排和重绘
- 使用浏览器缓存
- 使用webworker实现多线程

9. 对图片进行取主色的算法，怎么写
- 可以采用取均值法。红、绿、蓝分色分别提取然后取3个分色的平均值，最后将其组合起来
- 可以采用颜色聚类，找到聚类中心点作为主色（找一个点，跟平均值算法一样）

10. 对新技术的了解跟进
- 前端微服务
- vue3框架使用
- 大前端趋势，混合开发，一套代码多平台部署
- 可视化
- 前端AI
- node服务，中间层
- 服务端渲染

#### 复试：
1. 对JS的看法，3d图形实现有什么框架和技术
- JS语言是一种脚本语言，浏览器可以执行。它的优势是：语法简单、语法兼容性强、上手快。
- 缺点很明显，没有变量类型限制和变量预定义，导致bug出现的时候，难以找到bug出现的原因。对这个问题ts语言已经给出泪解决方案，通过添加类型定义，对变量的类型进行了限制。
- 此外浏览器中的JS代码是单线程，效率没有多线程高。在浏览器中可以通过使用webworker实现多线程。

2. https中间人攻击与防御，浏览器识别为https不安全网站的原理等等，
- https在http的基础上增加了身份校验、完整性检查、传输数据加密的功能。通过https的身份校验功能可以防止中间人攻击和防御。

3. http缓存 应用缓存之类的优化策略
- cache-control控制，max-age，Etag
4. 简历上的内容：前端监控上报方案
5. 前端安全问的很细
- xss脚本攻击（httpOnly、csp）
- csrf
- sql注入
- 点击劫持
6. Js基础知识