# 前端重要技术点详细讲解

##### 字节跳动（20190202）
- 一面
1. 基础知识
- axios或fetch的用法：
```javascript
function getData(url, data){
    // axios
    axios(url, data).then((res) => {
        console.log(res.data)
    }).catch((error) => {
        console.log(error)
    })
     // axios
    axios(
        {
            method: url, 
            params: data
        }
    )
    .then((res) => {
        console.log(res.data)
    })
    .catch((error) => {
        console.log(error)
    })
    // fetch
    fetch(url, data).then((res) => {
        res.json()
    }).catch((error) => {
        console.log(error)
    })
    // fetch
    fetch(url,
    {
        method: 'POST',
        body: data,
        headers: new Headers({'Content-Type': 'application/json'})
    }).then((res) => {
        res.json()
    }).catch((error) => {
        console.log(error)
    })
}   
```
2. promise实现delay(ms)延时函数
```javascript
    function delay(ms){
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve()
            }, ms)
        })
    }
```
3. react hook使用过吗
    使用过。react hook为react提供了提供了生命周期的功能，实现了监听状态变化和页面更新的功能。常用的hooks有useState、useEffect、useMemo、useCallback、useRef、useContext、useReducer等.其中useState是定义状态变量。useEffect对应了生命周期componentDidMount，但是监听的对象对象需要在通过给useEffect传参的形式实现。

4. 实现数组转链表
```javascript
    function arr2list(arr){
        class node{
            constructor(value, nextNode){
                this.value = value
                this.nextNode = nextNode
            }
        }
        const next = null
        for(let i = arr.length - 1; i >= 0; i--){
            arr[i] = new Node(arr[i], next)
            next = arr[i]
        }
        return next
    }
    function printList(list){
        let pointer = list
        whlie(pointer){
            console.log(pointer.value)
            pointer = pointer.nextNode
        }
    }
```
5. react中的函数组件和类组件有什么区别，实现一个函数来区分函数组建和类组件
    函数组件是函数形式的组件，在内部使用hooks监听状态和实现组件更新。函数组件通过props传参的形式实现父子组件间的信息传递，返回react的节点元素
    类组件是是使用类语法定义的组件，在内部使用react生命周期函数。通过constructor内部定义状态变量state，并定义内部的render函数返回react节点。
    如何实现一个函数来区分函数组件和类组件，我想可以使用以下方法：
    通过new一个对象判断该对象是否有rendor函数来实现。
6. html生成的DoM树是怎么样的。请用代码实现以下Dom结构
    Dom树的结构根节点为document，后面是html节点，再下面是元素head和元素body，head元素后是title，title后是文本节点。body下面可以是各种元素组合成的树形结构，比如a标签、h1标签等等，a标签又包含了href属性标签节点。可以绘制一个属性结构进行描述
    example：
    ```javascript
        1. const a = <div a={1}>click</div>
        2. const b = <Button disabled>click</Button>
    ```
    代码实现DOM结构，首先要清楚node节点的表示方法：
    ```javascript
    class Node{
        contructor(
            nodeName,
            nodevalue,
            nodeType, // 1: 元素，2: 属性，3: 文本，8: 注释，9: 文档
            parentNode,
            childNodes, 
            firstChild, 
            lastChild,
            attributes,
            previousSibling,
            nextSibling,
            innerHTML
        ){
            this.nodeName =nodeName
            ....
        }
    }
```javascript
// a的dom结构
const node2 = new Node('a', {1}, 2, null, null, null, null, null, null, null, null)
const node3 = new Node('#text', 'click', 3, null, null, null, null, null, null, null, null)
const node1 = new Node('div', null, 1, null, [node3], node3, node3, node2, null, null, 'click')
```
7. 了解虚拟Dom吗，用代码判断两个element是否全等。
    虚拟Dom的结构如下：
```javascript
class VNode{
    constructor(
        tag, // 标签类型：DIV、SPAN、#text
        el, // 对应的真实节点 Node类型
        children, // 当下节点下的子节点
        text, // 当前虚拟节点的文本
        data, // VNodeData(??)
        parent, // 父级节点 
        nodeType //  节点类型
    ){
        this.tag = tag
        ......
    }
}
    参考SnabbDOM：
    export interface VNodeData {
        props?: Props;
        attrs?: Attrs;
        class?: Classes;
        style?: VNodeStyle;
        dataset?: Dataset;
        on?: On;
        hero?: Hero;
        attachData?: AttachData;
        hook?: Hooks;
        key?: Key;
        ns?: string; // for SVGs
        fn?: () => VNode; // for thunks
        args?: Array<any>; // for thunks
        [key: string]: any; // for any other 3rd party module
    }
```
    如何判断是否全等？(全等的概念是什么意思？)
    1、对引用类型而言，全等的意思就是要求引用地址相同
    2、全等不要求引入地址相同，只需要内容一致，通过深度遍历对象实现
- 二面
1. display有哪些属性
    display： none unset initial inherit contents inline inline-block block flex grid table
2. flex能否实现元素竖排
    可以。主轴和交叉轴互换位置
3. css行内元素和块级元素的区别
    - 开启新行
    - 高度是否可以设定
    - 宽度是否可以设定
    - 内联元素只能容纳文本或者其他内联元素
4. 有哪些提升浏览器性能的方式
    - 资源分包
    - 懒加载
    - 减少请求次数
    - 静态资源CDN
    - 静态资源缓存
    - 资源文件压缩
    - 代码结构优化：减少循环、变量缓存、垃圾回收、减少dom结构的层级、节点缓存
    - 减少页面重绘和重排： 1、减少DOM节点的修改。 2、不要循环修改DOM的样式，最好使用改变className的方式实现样式的修改。3、定位为absolute和fixed的元素，修改它们的样式不会发生重排的
5. 从url输入到页面渲染完毕都经历了什么（包括通信部分和页面渲染）
    - url输入
    - DNS域名解析
    - 开始TCP三次握手
    - http内容传输
    - 客户端获得页面开始渲染解析，生成dom树，然后生成renderDom树，最后将页面进行绘制
6. 重绘和重排怎么理解？如何减少？
    当页面元素节点发生变化的时候，页面需要进行重新渲染，这个时候会发生重绘和重排
    - 重排一定会发生重绘，重绘不一定发生重排
    - 重排列的条件：
     - 页面渲染初始化
     - 添加、删除dom元素
     - 元素的位置改变
     - dom元素的尺寸改变
     - 浏览器窗口的尺寸改变
7. http有哪些请求方式？有什么区别？
    post get head options put delete connect trace 
    post：包含了请求头和请求主体 
    get：请求页面，没有请求body
    options：预检请求，可用于检测服务器的链接状态
    put: 从客户端向服务器传送的数据取代指定的内容
    head：跟get请求类似，响应只包含了报文头
    delete: 请求服务器删除指定的页面
    connect：将链接 改为 管道方式的代理服务器，用于传输http报文
    trace：回显服务器的请求，主要用于诊断和测试

8. http请求和收到的字段有哪些？有什么作用？
    请求字段
    通用头部：cache-control、Date、Pragma、connection、trailer、transfer-encoding、upgrade、via、warning
    请求头部：
    Host
    User-Agent
    Accept
    Accept-Language
    Accept-Encoding
    Accept-Charset
    Cookie
    Referer
    User-Agent
    Connection
    Cache-Control
    Range

    接受头部：
    - Cache-Control
    - Content-Type
    - Content-Encoding
    - Date
    - Server
    - Transfer-Encoding
    - Expires
    - Last-Modifyied
    - Connection
    - ETag
    - Refresh
    - Access-Control-Allow-Origin
    - Access-Control-Allow-Methods
    - Access-Control-Allow-Credencials
    - Content-Range
    - Location  // 重定向的位置
    - Set-Cookie

    origin和referer的区别：origin不携带路径，包含协议和host地址，只存在于post页面。可以用referrer-policy来监管哪些访问源信息会在referrer中送
9. 算法：财务室需要进行数字的处理，将1234567.90转化为1,234,567.90(适用于所有数字，要考虑特殊情况)
```javascript
    // 判断有没有小数点位置
    function toAcounting(num){
        let str = String(num)
        const index = str.indexOf('.')
        let start = 0
        let end = str.length
        if(index > -1){
             start = 0
             end = index
        }
        let loop = end
        while(loop > 3){
            str = str.slice(0, loop - 4)  + ',' + str.slice(loop-4, str.length)
            loop = loop - 4
        }
        return str
    }
```

- 三面
1. 讲一下你做过的项目，在项目中负责什么。

2. 在项目中遇到那些困难，是怎么解决的。
3. 不同页面间通信的方法，写代码。
 - js中可以使用storage来在同源页面进行通信
```javascript
    window.localStorage.setItem('a', 123)
    window.addEventListner('storage', (e) => {
        console.log(e.key, e.value)
    })
```
 - 非同源页面可以使用postMessage的方式来进行页面之间的通信
```javascript
    window.postMessage('12345', 'www.baidu.com')
    window.onmessage = (e) => {
        console.log(e.data, e.origin)
    }
```

4. 在构造函数中用bind绑定函数，前后是不是同一个（this指向考察）。
    - bind之后的函数和原函数不是同一个，地址不同
5. 如何收集产品发布后，实用阶段的问题。
    - 从问题维度：1、可能是生产bug，生产bug是需要及时响应和解决的问题，通常版本发布之后，测试同事会直接在线上验证，出现问题通知开发进行修复，并进行线上缺陷记录开启bug生命周期；2、可能是用户体验问题，这个可以由专门的产品体验官提供体验报告。可以从线上访问数据，如埋点的手段获得访问数据并进行分析，从而知道哪些功能更用户青睐，哪些功能有待改进。可以通过产品优化的方式，如通过app手机用户意见、反馈和投诉的方式实现实用阶段的问题；
    - 从收集渠道角度考虑： 1、测试出的生产bug。2、埋点收集待优化的功能。3、产品体验官的体验报告。4、产品的用户意见、反馈和投诉相关功能。5、线下用户回访。6、ABTest手段。6、灰度测试手段。其中一些寻找实用阶段问题的手段是需要其他工作人员配合完成的

##### 